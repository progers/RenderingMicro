<!DOCTYPE html>
<html>
<head>
  <title>Rendering Micro Benchmark</title>
  <style>
    body {
      font-family: sans-serif;
    }
    #container {
      display: flex;
    }
    #input, #preview {
      width: 50%;
      padding: 10px;
      border: 1px solid #ccc;
    }
    #input {
      white-space: pre;
      overflow-x: auto;
    }
    #preview {
      background-color: #f5f5f5;
    }
    #previewTitle {
      margin-bottom: 5px;
    }
    #run {
      margin: 10px 0;
      padding: 8px 16px;
    }
    #warnings {
      display: none;
      background-color: bisque;
      border: 1px solid redbrick;
    }
  </style>
</head>
<body>
  <h1>Rendering Micro Benchmark</h1>
  <p>Enter HTML snippets below to benchmark their performance.</p>
  <p id="warnings"></p>

  <div id="container">
    <textarea id="input" rows="10"></textarea>
    <div id="preview">
      <h2>Preview</h2>
      <div id="previewContent"></div>
    </div>
  </div>

  <button id="run">Run Benchmark</button>

  <h2>Results</h2>
  <div id="results"></div>

  <script>
    onload = () => {
      input.addEventListener('input', () => {
        updatePreviewContent();
        updateUrlHashForSharing();
      });

      run.addEventListener('click', () => {
        runTests();
      });

      showTimerQuantizationWarningIfNeeded();

      // If set, use the window location hash for testcases. Otherwise, use a
      // set of predefined examples.
      const hash = window.location.hash.substring(1);
      input.value = hash ? atob(hash) : exampleTestcases.trim();
      updatePreviewContent();
    }

    function updatePreviewContent() {
      previewContent.innerHTML = '';
      for (const testcase of getTestcases(1)) {
        previewContent.innerHTML += `<h4>${testcase.name}</h4>${testcase.html}`;
      }
    }

    function updateUrlHashForSharing() {
      const encodedHTML = btoa(input.value);
      const newURL = window.location.origin + window.location.pathname + '#' + encodedHTML;
      window.history.replaceState({}, '', newURL);
    }

    class Testcase {
      constructor(name, html) {
        this.name = name;
        this.html = html;

        this.parseTime = 0;
        this.styleLayoutTime = 0;
        this.paintTime = 0;
      }
    }

    async function waitForFrame() {
      return new Promise(requestAnimationFrame);
    }

    async function waitForTimeout(t = 0) {
      return new Promise((resolve, reject) => setTimeout(resolve, t))
    }

    async function runTests() {
      const testRepeat = 10;
      const testcases = getTestcases(testRepeat);

      const debugTimestamps = true;

      // TODO: Ensure the rest of the DOM isn't affecting this.
      const bench = document.createElement('div');
      results.replaceChildren(bench);

      // TODO: Add warmup.
      // TODO: Randomize testcases.

      let startParseTime = 0;
      let startStyleLayoutTime = 0;
      let startPaintTime = 0;
      let endPaintTime = 0;

      // Wait for quiescence.
      await waitForTimeout(200);

      for (const testcase of testcases) {
        bench.innerHTML = '';
        // Give gc a chance between repeats.
        await waitForTimeout(20);
        await waitForFrame();
        await waitForFrame();

        startParseTime = performance.now();
        bench.innerHTML = testcase.html;
        startStyleLayoutTime = performance.now();
        bench.offsetWidth; // force layout.
        startPaintTime = performance.now();
        await waitForTimeout();
        endPaintTime = performance.now();

        testcase.parseTime = startStyleLayoutTime - startParseTime;
        testcase.styleLayoutTime = startPaintTime - startStyleLayoutTime;
        testcase.paintTime = endPaintTime - startPaintTime;

        if (debugTimestamps) {
          performance.mark(`${testcase.name} - startParse`, {startTime: startParseTime});
          performance.mark(`startStyleLayout`, {startTime: startStyleLayoutTime});
          performance.mark(`startPaintTime`, {startTime: startPaintTime});
          performance.mark(`endPaintTime`, {startTime: endPaintTime});
        }
      }

      results.innerHTML = summarizeResults(testcases);
    }

    function summarizeResults(testcases) {
      let results = '';
      const totals = testcases.reduce((acc, curr) => {
        acc[curr.name] = acc[curr.name] || {parse: 0, styleLayout: 0, paint: 0, total: 0, count: 0};
        acc[curr.name].parse += curr.parseTime;
        acc[curr.name].styleLayout += curr.styleLayoutTime;
        acc[curr.name].paint += curr.paintTime;
        acc[curr.name].total += curr.parseTime + curr.styleLayoutTime + curr.paintTime;
        acc[curr.name].count++;
        return acc;
      }, {});
      for (const name in totals) {
        let total = totals[name];
        results += `<b>${name}: ${parseFloat((total.total / total.count).toFixed(3))} ms</b>:<br>`;
        results += `  parse: ${parseFloat((total.parse / total.count).toFixed(3))} ms<br>`;
        results += `  styleLayout: ${parseFloat((total.styleLayout / total.count).toFixed(3))} ms<br>`;
        results += `  paint: ${parseFloat((total.paint / total.count).toFixed(3))} ms<br><br>`;
      }
      return results;
    }

    // Parse testcases from #input and return an array of |repeatCount| unique
    // testcases, where a testcase is made unique by replacing all instances of
    // the name in the html with "name_" and an id.
    function getTestcases(repeatCount) {
      let testcases = [];
      let scratch = document.createElement('div');
      scratch.innerHTML = input.value;
      for (const div of scratch.querySelectorAll('testcase')) {
        for (let i = 0; i < repeatCount; i++) {
          let name = div.getAttribute('name');
          let uniqueHtml = div.innerHTML.replaceAll(name, `${name}_${i}`);
          testcases.push(new Testcase(name, uniqueHtml));
        }
      }
      return testcases;
    }

    function showTimerQuantizationWarningIfNeeded() {
      if (!self.crossOriginIsolated) {
        warnings.style.display = 'inline';
        warnings.innerHTML = '<b>Warning:</b> Timer precision impacted because not <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/crossOriginIsolated">cross-origin isolated</a>. Use <code>python3 crossOriginIsolatedServer.py</code>.</p>';
      }
    }

    const exampleTestcases = `
<testcase name="svg-image">
  <style>
    .svg-image {
      display: inline-block;
      height: 24px;
      width: 24px;
      background-image: url('data:image/svg+xml,<svg uinqueid="svg-image" focusable="false" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23747878" d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg>');
    }
  </style>
  <div class="svg-image"></div>
</testcase>

<testcase name="inline-svg">
  <style>
    .inline-svg {
      display: inline-block;
      height: 24px;
      width: 24px;
      fill: #747878;
    }
  </style>
  <svg class="inline-svg" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"></path>
  </svg>
</testcase>

<testcase name="css-clip-path">
  <style>
    .css-clip-path {
      clip-path: path('M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z');
      display: inline-block;
      height: 24px;
      width: 24px;
      background-color: #747878;
    }
  </style>
  <div class="css-clip-path"></div>
</testcase>`;
  </script>
</body>
</html>
